\name{AhrdOnGeneClusters-package}
\alias{AhrdOnGeneClusters-package}
\alias{AhrdOnGeneClusters}
\docType{package}
\title{
Automated Assignment of Human Readable Descriptions on Gene Clusters generated by Markov Clustering
~~ AhrdOnGeneClusters ~~
}
\description{
  AhrdOnGeneClusters annotates Gene Clusters with Human Readable
  Descriptions. Gene Clusters are sets of amino acid sequence of significant
  similarity.

  Gene clusters, interpreted as gene families, enable several conclusions and
  interpretations: Like gene expansion or loss in a certain organism,
  phylogenetic reconstruction in order to reconstruct the evolutionary history
  of the genes of your interest etc.

  The problem is, that no cluster has a short, concise, and trustworthy human
  readable description that gives you a quick overview of what kind of gene
  family you are dealing with here. And typically you have many such clusters.
  â€“ In the Tomato genome for istance we had 17,490!

  This version of AHRD (see https://github.com/groupschoof/AHRD for the
  original used to describe single query proteins) provides a simple method to
  annotate such gene clusters.
}
\details{
\tabular{ll}{
Package: \tab AhrdOnGeneClusters\cr
Type: \tab Package\cr
Version: \tab 1.0\cr
Date: \tab 2014-06-12\cr
License: \tab GPL 3.0\cr
}
~~ An overview of how to use the package, including the most important functions ~~
}
\author{
Asis Hallab

Maintainer: <hallab@mpipz.mpg.de>
}
\references{
}
\keyword{ package Markov Clustering Gene-Families OrthoMCL InParanoid MCL }
\seealso{
}
\examples{
~~ Annotate a set of gene families with short human readable descriptions ~~

# Have your gene clusters ready in a named list of character vectors, in which
# each gene family is represented by a single character vector of gene
# accessions. Here, the list names are the family-names.
mcl.fams <- list( 'group1'=c( 'AT2G98278', 'Solyc4G29337' ), 'group2'=c( ...

# Have the InterPro annotations ready in a data.frame. The data.frame is required
# to have two columns, in which the first is to hold the gene accession and the
# second the annotated InterPro entry. In order to get correct frequencies it is
# necessary to ensure that each protein's InterPro annotation only appears once.
# To ensure use unique(...) after reading in the InterPro annotations.
gene.2.ipr.df <- unique( read.table( 'my.ipr.annos.csv', stringsAsFactors=FALSE ) )

# Load the downloaded InterPro database into memory:
ipr.db <- parseInterProXML( './interpro.xml' ) 

# Annotate your gene families:
mcl.fams.hrds <- lapply( mcl.fams, annotateCluster, ipr.annos=gene.2.ipr.df,
  interpro.database=ipr.db )
# Usage of mclapply is recommended:
require( parallel )
options('mc.cores'=detectCores())
mcl.fams.hrds <- mclapply( mcl.fams, annotateCluster, ipr.annos=gene.2.ipr.df,
  interpro.database=ipr.db )

######################################################
# Annotate using human readable protein descriptions #
######################################################

# Prepare and load description data-base (example is for Uniprot Swissprot and
# Uniprot trEMBL) This requires an underlying System which supports the 'grep'
# command:
my.prot.desc.db <- readProteinDescriptionDb( 'path/2/your_database.fasta' )
# Note, that depending on which database you use (Uniprot or NCBI or any other)
# you might have to provide non default values for the arguments
# 'prot.id.regex' and 'prot.short.id.regex'. This package's defaults are
# adjusted to the UniprotKB format.

# Annotate your protein families using candidate protein descriptions. See
# AhrdOnGeneClusters::annotateClusterWithProteinDescription for more
# details, especially on which protein ID to use when looking up candidate
# descriptions in my.prot.desc.db.
mcl.fams.prot.descs <- setNames( lapply( mcl.fams,
  annotateClusterWithProteinDescription, prot.desc.db = my.prot.desc.db ),
  names(mcl.fams)
)

# Or do the above in parallel by
options(mc.cores=detectCores())
mcl.fams.prot.descs <- setNames( mclapply( mcl.fams,
  annotateClusterWithProteinDescription, prot.desc.db = my.prot.desc.db ),
  names(mcl.fams)
)
}
